// Generated by CoffeeScript 2.1.1
(function() {
  var Draw, init;

  Draw = (function() {
    var StylesParser;

    class Draw {
      constructor(width, height, properties_settings) {
        var SVG, document, window;
        window = require('svgdom');
        SVG = require('svg.js')(window);
        document = window.document;
        this.draw = SVG(document.documentElement).size(width, height);
        this.styles_parser = new StylesParser(properties_settings);
      }

      clear() {
        this.draw.clear();
        return this;
      }

      svg() {
        return this.draw.svg();
      }

      item_box(item) {
        var item_style;
        item_style = this.styles_parser.parse_item_styles(item['type'], item['data']);
        this.draw_handler('item_box', [item['position']], item_style).call();
        return this;
      }

      items(items_matrix) {
        var item, j, k, len, len1, rows;
        for (j = 0, len = items_matrix.length; j < len; j++) {
          rows = items_matrix[j];
          for (k = 0, len1 = rows.length; k < len1; k++) {
            item = rows[k];
            this.item_box(item);
          }
        }
        return this;
      }

      draw_handler(type, positions, style) {
        var $this;
        $this = this;
        return function() {
          var height, left, top, width;
          switch (type) {
            case 'item_box':
              left = positions[0]['left'];
              top = positions[0]['top'];
              width = positions[0]['right'] - positions[0]['left'];
              height = positions[0]['bottom'] - positions[0]['top'];
              return $this.draw.rect(width, height).radius(8).fill('yellow').move(left, top);
          }
        };
      }

    };

    StylesParser = class StylesParser {
      constructor(properties_settings) {
        this.properties_settings = properties_settings;
      }

      get_item_styles(item_type, item_data) {
        var default_category_style, properties_styles, property, property_uid, ref, value_style;
        properties_styles = {};
        default_category_style = this.properties_settings['styles'][this.properties_settings['categories_styles'][item_type]];
        if (default_category_style == null) {
          default_category_style = {};
        }
        ref = this.properties_settings['properties'][item_type];
        for (property_uid in ref) {
          property = ref[property_uid];
          value_style = this.properties_settings['styles'][property['values'][item_data[property_uid]]];
          if (value_style == null) {
            value_style = {};
          }
          properties_styles[property_uid] = {
            default_property_style: this.properties_settings['styles'][property['style']],
            sort: property['sort'],
            value_style: value_style
          };
        }
        return {
          default_category_style: default_category_style,
          properties_styles: properties_styles
        };
      }

      parse_item_styles(item_type, item_data) {
        var $this, item_result_style, item_styles, merged_property_style, property_style, property_uid, ref;
        // возвращает hash определния стиля для заданного item (ключи - css свойства)
        // алгоритм:
        // - получаем hash стилей (get_item_styles)
        // - для каждого property в хэше стилей определяем приоритетеный стиль (merge default_property_style и value_style c приоритетеом value_style)
        // - определяем приоритетеный стиль по всем properties /merged_properties_style/ (merge c учетом sort по каждому значению хэшей определений стилей)
        // - merge default_category_style и merged_properties_style (c приоритетом merged_properties_style по каждому свойству хэшей определений стилей)
        $this = this;
        item_styles = this.get_item_styles(item_type, item_data);
        item_result_style = {
          'style': item_styles['default_category_style'],
          'sort': -1
        };
        ref = item_styles['properties_styles'];
        for (property_uid in ref) {
          property_style = ref[property_uid];
          merged_property_style = $this.merge_styles({
            'style': property_style['default_property_style'],
            'sort': 0
          }, {
            'style': property_style['value_style'],
            'sort': property_style['sort']
          });
          item_result_style = $this.merge_styles(item_result_style, merged_property_style);
        }
        return item_result_style['style'];
      }

      merge_styles(first_style, second_style) {
        var j, key, len, merged_style, merged_style_keys;
        // first_style, second_style = {'style': {хэш с определением стиля, ключи - свойства css}, 'sort': числовое_значение_веса_стиля }
        // возвращает {хэш с определением стиля; ключи - свойства css, объединение ключей обоих стилей}
        // алгоритм:
        // -- получаем массив объединения ключей-свойств хэшей стилей
        // -- определяем результирующий хэш
        // -- добавлем в результирующий хэш значения для каждого совйства, перебирая по всем ключам и сравнивая веса стилей:
        //    --- если в одном из хешей стилей ключа нет - берем значение из того, в котором значения для ключа определено
        //    --- если определено в обоих хэшах, берем из того, в котором sort больше; если sort одинаковое - берем значение из first_style
        merged_style = {};
        merged_style_keys = Object.keys(first_style['style']).concat(Object.keys(second_style['style'])).filter(function(x, i, a) {
          return a.indexOf(x) === i;
        });
        for (j = 0, len = merged_style_keys.length; j < len; j++) {
          key = merged_style_keys[j];
          if (second_style['style'][key] == null) {
            merged_style[key] = first_style['style'][key];
          }
          if (first_style['style'][key] == null) {
            merged_style[key] = second_style['style'][key];
          }
          if ((first_style['style'][key] != null) && (second_style['style'][key] != null)) {
            merged_style[key] = first_style['sort'] >= second_style['sort'] ? first_style['style'][key] : second_style['style'][key];
          }
        }
        return {
          'style': merged_style,
          'sort': Math.max(first_style['sort'], second_style['sort'])
        };
      }

    };

    return Draw;

  }).call(this);

  init = function(width, height, properties_settings) {
    return new Draw(width, height, properties_settings);
  };

  exports.init = init;

}).call(this);
